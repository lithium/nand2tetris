class Jhvm {
  field String _outPath;
  field int _outfd;

  field int _arg2idx;

  field int _SP;

  static String DOTASM;
  static String DOTVM;
  static String SLASHES;
  static String TRANSLATING;
  static String WHITESPACE;
  static String COMMENT;

  static String ADD;
  static String SUB;
  static String NEG;
  static String EQ;
  static String GT;
  static String LT;
  static String AND;
  static String OR;
  static String NOT;
  static String PUSH;
  static String POP;
  static String ARGUMENT;
  static String LOCAL;
  static String STATIC;
  static String CONSTANT;
  static String THIS;
  static String THAT;
  static String POINTER;
  static String TEMP;
  static String LABEL;
  static String GOTO;
  static String IFGOTO;
  static String FUNCTION;
  static String CALL;
  static String RETURN;

  static String PUSH_POSTAMBLE;
  static String POP_PREAMBLE;
  static String POP_POSTAMBLE;
  static String POP_TWOARGS;
  static String STACK_INC;
  static String ADD_MD;

  constructor Jhvm new()
  {
    let _outfd = -1;
    let _SP = 256;
    return this;
  }

  function void init()
  {
    let DOTVM = ".vm";
    let DOTASM = ".asm";
    let SLASHES = "/\\";
    let TRANSLATING = "Translating ";
    let WHITESPACE = " \t";
    let COMMENT = "//";

    let ADD = "add";
    let SUB = "sub";
    let NEG = "neg";
    let EQ = "eq";
    let GT = "gt";
    let LT = "lt";
    let AND = "and";
    let OR = "or";
    let NOT = "not";
    let PUSH = "push";
    let POP = "pop";
    let ARGUMENT = "argument";
    let LOCAL = "local";
    let STATIC = "static";
    let CONSTANT = "constant";
    let THIS = "this";
    let THAT = "that";
    let POINTER = "pointer";
    let TEMP = "temp";
    let LABEL = "label";
    let GOTO = "goto";
    let IFGOTO = "if-goto";
    let FUNCTION = "function";
    let CALL = "call";
    let RETURN = "return";


    // translated push command
    //    @<value>
    //    D=A
    //    @SP
    //    A=M
    //    M=D
    //    @SP
    //    M=M+1
    let PUSH_POSTAMBLE = "\n D=A\n @SP\n A=M\n M=D\n @SP\n M=M+1\n";


    // translated pop command
    //  @SP           
    //  M=M-1
    //  A=M
    //  D=M
    //  @<address>    
    //  M=D
    let POP_PREAMBLE = "\n @SP\n M=M-1\n A=M\n D=M\n ";
    let POP_POSTAMBLE = "\n M=D\n";


    // stack operations
    let POP_TWOARGS = "\n @SP\n M=M-1\n A=M\n D=M\n @SP\n M=M-1\n A=M\n";
    let STACK_INC = "\n @SP\n M=M+1\n";

    // arithmetic operations
    let ADD_MD = "\n M=M+D\n";


    do Path.init();
    return;
  }

  method String setOutputPath(String argument)
  {
    var int l;
    var Array a;

    let l = argument.length();
    let a = argument.bytes();

    if (argument.compare(-3, DOTVM, 0, 3) = 0) {
      // replace .vm with .asm

      let _outPath = String.new(l+1);
      do Array.copy(_outPath.bytes(), a, l-2);
      do Array.copy(_outPath.bytes()+l-2, DOTASM.bytes()+1, 3);
      do _outPath.setLength(l+1);
    } else {
      // trim any trailing / and append .asm

      do argument.rstrip(SLASHES);
      let l = argument.length();
      let _outPath = String.new(l+4);
      do Array.copy(_outPath.bytes(), a, l);
      do Array.copy(_outPath.bytes()+l, DOTASM.bytes(), 4);
      do _outPath.setLength(l+4);
    }
    return _outPath;
  }

  method boolean openOutputFile()
  {
    if (_outPath = null) {
      return false;
    }
    let _outfd = File.open(_outPath, 1);
    return (~(_outfd = -1));
  }
  method boolean closeOutputFile() 
  {
    if (_outfd = -1) {
      return false;
    }
    do File.close(_outfd);
    let _outfd = -1;
    return true;
  }
  method int _nextTokenEnd(String line, int start) 
  {
    var int idx;

    let idx = line.indexOfChar(32, start);   // ' '
    if (idx = -1) {
      let idx = line.length();
    }
    return idx;
  }

  method boolean translateFile(String filename)
  {
    var int fh;
    var String line;
    var String arg1;

    do Output.printString(TRANSLATING);
    do Output.printString(filename);
    do Output.println();


    let fh = File.open(filename, 0);
    if (fh = -1) {
      return false;
    }

    while(File.ready(fh) = 1) {
      let line = File.readln(fh);

      do Jhvm.stripWhitespace(line);
      if (line.length() > 0) {
      /*
        do Output.printString("IN:");
        do Output.printString(line);
        do Output.println();
      */

        let arg1 = null;
        if (line.compare(0, PUSH, 0, 4) = 0) {
          let arg1 = _parseArgument1(line);
          do _push(arg1, _parseArgument2(line));
        } else {
        if (line.compare(0, POP, 0, 3) = 0) {
          let arg1 = _parseArgument1(line);
          do _pop(arg1, _parseArgument2(line));
        } else {
        if (line.compare(0, FUNCTION, 0, 8) = 0) {
          let arg1 = _parseArgument1(line);
          do _function(arg1, _parseArgument2(line));
        } else {
        if (line.compare(0, CALL, 0, 3) = 0) {
          let arg1 = _parseArgument1(line);
          do _call(arg1, _parseArgument2(line));
        } else {
        if (line.compare(0, LABEL, 0, 5) = 0) {
          let arg1 = _parseArgument1(line);
          do _label(arg1);
        } else {
        if (line.compare(0, GOTO, 0, 4) = 0) {
          let arg1 = _parseArgument1(line);
          do _goto(arg1);
        } else {
        if (line.compare(0, IFGOTO, 0, 6) = 0) {
          let arg1 = _parseArgument1(line);
          do _if_goto(arg1);
        } else {
        if (line.compare(0, RETURN, 0, 6) = 0) {
          do _return();
        } else {
        if (line.compare(0, ADD, 0, 3) = 0) {
          do _add();
        } else {
          do Output.printString("unhandled: ");
          do Output.printString(line);
          do Output.println();
        }}}}}}}}}

        if (~(arg1 = null)) {
          do arg1.dispose();
          let arg1 = null;
        }


      }

      do line.dispose();
    }
    return true;
  }

  function void stripWhitespace(String line) 
  {
    var int idx;

    // strip comments
    let idx = line.indexOf(COMMENT);
    if (~(idx = -1)) {
      do line.setLength(idx);
    }

    // strip whitespace
    do line.rstrip(WHITESPACE);
    do line.lstrip(WHITESPACE);

    return;
  }

  method String _parseArgument1(String line)
  {
    var int argsStart;
    var int idx;

    let argsStart = _nextTokenEnd(line, 0)+1;
    let _arg2idx = _nextTokenEnd(line, argsStart)+1;

    return line.subString(argsStart, _arg2idx - argsStart-1);
  }
  method int _parseArgument2(String line)
  {
    var String arg2;
    var int ret;

    let arg2 = line.subString(_arg2idx, line.length()-_arg2idx);
    let ret = arg2.intValue();
    do arg2.dispose();

    return ret;
  }

  method int _resolveSegment(String segment, int offset)
  {
    if (segment.compare(0, CONSTANT,0, 8) = 0) {
      return offset;
    }

    return -1;
  }

  method void _push(String segment, int offset) 
  {
    var int value;
    var String loadValue;

    do Output.printString("Push segment:");
    do Output.printString(segment);
    do Output.printString(" offset:");
    do Output.printInt(offset);
    do Output.println();

    let value = _resolveSegment(segment, offset);
    let loadValue = String.new(6);
    do loadValue.setCharAt(0, 64);     // '@'
    do loadValue.setIntAt(1, value);

    //    @<value>
    //    D=A
    //    @SP
    //    A=M
    //    M=D
    //    @SP
    //    M=M+1
    do File.write(_outfd, loadValue);
    do File.write(_outfd, PUSH_POSTAMBLE);


    do loadValue.dispose();
    return;
  }

  method void _pop(String segment, int offset) {
    var int address;
    var String loadValue;

    do Output.printString("Pop segment:");
    do Output.printString(segment);
    do Output.printString(" offset:");
    do Output.printInt(offset);
    do Output.println();

    let address = _resolveSegment(segment, offset);
    let loadValue = String.new(6);
    do loadValue.setCharAt(0, 64);     // '@'
    do loadValue.setIntAt(1, address);

    //  @SP           
    //  M=M-1
    //  A=M
    //  D=M
    //  @<address>    
    //  M=D
    do File.write(_outfd, POP_PREAMBLE);
    do File.write(_outfd, loadValue);
    do File.write(_outfd, POP_POSTAMBLE);


    return;
  }

  method void _add()
  {
    do Output.printString("Add");
    do Output.println();

    do File.write(_outfd, POP_TWOARGS);
    do File.write(_outfd, ADD_MD);
    do File.write(_outfd, STACK_INC);

    //    @SP           // D = *--SP
    //    M=M-1
    //    A=M
    //    D=M

    //    @SP           // *SP++ = *--SP + D
    //    M=M-1
    //    A=M
    //    M=M+D
    //    @SP
    //    M=M+1



    return;
  }

  method void _function(String functionName, int nLocals)
  {
    return;
  }

  method void _call(String functionName, int nArgs)
  {
    return;
  }

  method void _return()
  {
    return;
  }

  method void _label(String symbol)
  {
    return;
  }

  method void _goto(String symbol)
  {
    return;
  }

  method void _if_goto(String symbol)
  {
    return;
  }

}