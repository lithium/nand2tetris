


class Jhasm 
{
  field SymbolTable _symbols;


  constructor Jhasm new()
  {
    let _symbols = SymbolTable.new();

    return this; 
  } 

  /*
   * Assemble source lines and return a ArrayList of Hack binary
   */
  method ArrayList assemble(ArrayList inText)
  {
    var ArrayList out;
    var ArrayList scrubbed;
    var int i;
    var int l;
    var String line;

    let scrubbed = firstPass(inText);


    /* Second Pass: compile each instruction */
    let i = 0;
    let l = scrubbed.size();
    let out = ArrayList.new(l);

    while (i < l) {
      let line = _compileInstruction(scrubbed.get(i));
      if (line = null) {
        do Output.printString(scrubbed.get(i));
        do Output.printString("Invalid instruction on line ");
        do Output.printInt(i+1);
        do Output.println();
        return null;
      }
      do out.add(line);
      let i = i + 1;
    }

    return out;
  }

  /*
   * First Pass:
   *  - strip comments and blank lines
   *  - builds symbol table and strips label lines
   * Returns a new ArrayList of instructions that should map 1to1 to machine code.
   */
  method ArrayList firstPass(ArrayList input) 
  {
    var ArrayList ret;
    var int i;
    var int l;
    var String line;
    var int idx;
    var int labelStart, labelEnd;
    var String label;
    var int lineno;

    let l = input.size();
    if (l < 1) {
      return null;
    }
    let ret = ArrayList.new(l);

    let i = 0;
    while (i < l) {
      let line = input.get(i); 

      // strip comments
      let idx = line.indexOf("//");
      if (~(idx = -1)) {
        do line.setLength(idx);
      }

      // strip whitespace
      do line.rstrip(" \t");
      do line.lstrip(" \t");

      // check if its a label
      let label = null;
      let labelStart = line.indexOfChar(40, 0);    // '('
      if (~(labelStart = -1)) {
        let labelEnd = line.indexOfChar(41, labelStart);  // ')'
        if (labelStart = -1) {
          do Output.printString("Invalid label on line ");
          do Output.printInt(ret.size());
          do Output.println();
          do ret.dispose();
          return null;
        }

        let label = line.subString(labelStart+1, labelEnd - labelStart-1);
        do _symbols.setSymbol(label, ret.size());
      } 

      // add line if it wasnt a label and its not empty
      if ((label = null) & (line.length() > 0)) {
        do ret.add(line);
      }

      let i = i + 1;
    }

    return ret;
  }

  /*
   * Translate a Hack Assembler mneumonic into Hack Binary
   */
  method String _compileInstruction(String instruction)
  {
    var String address;
    var String inst;
    var int addr;

    var int compIdx;
    var int jumpIdx;
    var String dest, comp, jump;
    var int d, c, j;
    var int i;

    if (instruction.charAt(0) = 64) {   // '@'
      // A- Instruction

      let address = String.newFromBytes(instruction.bytes()+1, instruction.length()-1);
      let addr = address.intValue();
      if (addr = -1) {
        // no integer constant, assume its a symbol
        let addr = _symbols.resolveSymbol(address);
      }

      return Jhasm.binaryString(addr);
    }

    // C- Instruction

    let compIdx = instruction.indexOfChar(61, 0);   // '=' 
    let jumpIdx = instruction.indexOfChar(59, 0);   // ';' 

    let d = 0;
    let c = 0;
    let j = 0;
    if (~(compIdx = -1)) {
      // dest instruction

      let dest = String.newFromBytes(instruction.bytes(), compIdx);
      let comp = String.newFromBytes(instruction.bytes() + compIdx+1, 
                                     instruction.length()-compIdx-1);

      let d = Jhasm.destFromMneumonic(dest);
      let c = Jhasm.compFromMneumonic(comp);
    } else {
      if (~(jumpIdx = -1)) {
        // jump instruction
        let comp = String.newFromBytes(instruction.bytes(), jumpIdx-1);
        let jump = String.newFromBytes(instruction.bytes()+jumpIdx+1,
                                       instruction.length()-jumpIdx-1);

        let c = Jhasm.compFromMneumonic(comp);
        let j = Jhasm.jumpFromMneumonic(jump);
      } else {
        // invalid instruction
        return null;
      }
    }

    let i = 0;
    let i = i | ((c & 127) * 64);    // i |= (c & 0x7f) << 6
    let i = i | ((d & 7) * 8);       // i |= (d & 0x7) << 3
    let i = i | (j & 7);             // i |= (j & 0x7)

    let inst = Jhasm.binaryString(i);
    do inst.setCharAt(0, 49);        // i |= 0b1110000000000000
    do inst.setCharAt(1, 49);
    do inst.setCharAt(2, 49);
    return inst;
  }



  /* static funtions */

  function String binaryString(int word)
  {
    var String ret;
    var int i;
    var int mask;

    let ret = String.new(16);
    let mask = 1;
    let i = 0;
    while (i < 16) {
      if (word & mask) {
        do ret.setCharAt(15-i, 49);    // '1'
      } else {
        do ret.setCharAt(15-i, 48);    // '0'
      }

      let mask = mask * 2;
      let i = i + 1;
    }
    do ret.setLength(16);
    return ret;
  }

  function int destFromMneumonic(String dest)
  {
    var int i;
    var int d;
    let d = 0;

    let i = dest.indexOfChar(65, 0);   // 'A'
    if (~(i = -1)) {
      let d = d | 4;
    }
    let i = dest.indexOfChar(68, 0);   // 'D'
    if (~(i = -1)) {
      let d = d | 2;
    }
    let i = dest.indexOfChar(77, 0);   // 'M'
    if (~(i = -1)) {
      let d = d | 1;
    }
    return d;
  }

  function int jumpFromMneumonic(String jump)
  {
    if (jump.equals("JMP")) { return 7; }
    if (jump.equals("JLE")) { return 6; }
    if (jump.equals("JNE")) { return 5; }
    if (jump.equals("JLT")) { return 4; }
    if (jump.equals("JGE")) { return 3; }
    if (jump.equals("JEQ")) { return 2; }
    if (jump.equals("JGT")) { return 1; }

    return 0;
  }  

  function int compFromMneumonic(String comp)
  {
    return 0;
  }
}